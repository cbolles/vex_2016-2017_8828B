#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    rightPot,       sensorNone)
#pragma config(Sensor, in2,    leftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    leftFollower,   sensorLineFollower)
#pragma config(Sensor, in4,    rightFollower,  sensorLineFollower)
#pragma config(Sensor, in5,    threeStarLine,  sensorLineFollower)
#pragma config(Sensor, dgtl1,  autoSensor,     sensorTouch)
#pragma config(Sensor, dgtl2,  bottomLimit,    sensorNone)
#pragma config(Sensor, dgtl3,  autoSensor,     sensorNone)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightPincer,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           bottomRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           topLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           backRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           backLeft,      tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           bottomLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topRight,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port10,          leftPincer,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "autoInclude.h"

int autoSelect = 0; //0=cube, 1=basic,2=backThree, 3=backTwo
/*
<summary>
Allows the user to select the auto to run
</summary>
*/
task selectAuto()
{
	bLCDBacklight = true;
	int currentOption = 0;
	clearLCDLine(0);
	clearLCDLine(1);
	string autoOptions[] = {"cube", "basic", "backThree", "backTwo"};
	while()
	{
		clearLCDLine(0);
		clearLCDLine(1);

		if(nLCDButtons == kButtonRight)
		{
			currentOption++;
		}
		else if(nLCDButtons == kButtonLeft)
		{
			currentOption--;
		}

		if(currentOption > 3)
		{
			currentOption = 0;
		}
		else if(currentOption < 0)
		{
			currentOption = 3;
		}

		if(nLCDButtons == kButtonCenter)
		{
			autoSelect = currentOption;
		}

		if(currentOption == autoSelect)
		{
			displayLCDPos(1,0);
			displayNextLCDString("Selected");
		}

		displayLCDPos(0,0);
		displayNextLCDString(autoOptions[currentOption]);
		wait1Msec(250);
	}
}
void pre_auton()
{
	bLCDBacklight = true;
	int currentOption = 0;
	clearLCDLine(0);
	clearLCDLine(1);
	string autoOptions[] = {"cube", "basic", "backThree", "backTwo"};
	while(bIfiRobotDisabled)
	{
		clearLCDLine(0);
		clearLCDLine(1);

		if(nLCDButtons == kButtonRight)
		{
			currentOption++;
		}
		else if(nLCDButtons == kButtonLeft)
		{
			currentOption--;
		}

		if(currentOption > 3)
		{
			currentOption = 0;
		}
		else if(currentOption < 0)
		{
			currentOption = 3;
		}

		if(nLCDButtons == kButtonCenter)
		{
			autoSelect = currentOption;
		}

		if(currentOption == autoSelect)
		{
			displayLCDPos(1,0);
			displayNextLCDString("Selected");
		}

		displayLCDPos(0,0);
		displayNextLCDString(autoOptions[currentOption]);
		wait1Msec(250);
	}
	bStopTasksBetweenModes = true;
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/



task autonomous()
{
	clearTimer(T2);
	startTask(odometry);
	setToDefault();
	if(autoSelect == 0)
	{
		cube();
	}
	else if(autoSelect == 1)
	{
		basicAuto();
	}
	else if(autoSelect == 2)
	{
		backStars();
	}
	else if(autoSelect == 3)
	{
		backTwo();
	}
	writeDebugStreamLine("%d:",time1(T2));
}

//Gets Joystick Values with dead zone
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
void driveControl()
{
	//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

	//Loop Forever
	//Create "deadzone" for Y1/Ch3
	if(abs(vexRT[Ch3]) > threshold)
		Y1 = vexRT[Ch3];
	else
		Y1 = 0;
	//Create "deadzone" for X1/Ch4
	if(abs(vexRT[Ch4]) > threshold)
		X1 = vexRT[Ch4];
	else
		X1 = 0;
	//Create "deadzone" for X2/Ch1
	if(abs(vexRT[Ch1]) > threshold)
		X2 = vexRT[Ch1];
	else
		X2 = 0;

	//Remote Control Commands
	motor[frontRight] = Y1 - X2 - X1;
	motor[backRight] =  Y1 - X2 + X1;
	motor[frontLeft] = Y1 + X2 + X1;
	motor[backLeft] =  Y1 + X2 - X1;
}

//Basic open and close of pincher claws
int clawAdditionalPower = 0;
void movePincher()
{
	int motorSpeed = 50;
	if(vexRT[Btn8L])
	{
		motor[leftPincer] = motorSpeed;
	}
	else if(vexRT[Btn8R])
	{
		motor[leftPincer] = -motorSpeed;
	}
	else
	{
		motor[leftPincer] = clawAdditionalPower;
	}

	if(vexRT[Btn7R])
	{
		motor[rightPincer] = -motorSpeed;
	}
	else if (vexRT[Btn7L])
	{
		motor[rightPincer] = motorSpeed;
	}
	else
	{
		motor[rightPincer] = clawAdditionalPower;
	}
}

bool lockClawButtonPressed = false;
bool lockPincer = false;
void lockClaw()
{
	if(vexRT[Btn7D] && !lockClawButtonPressed)
	{
		lockPincer = !lockPincer;
		lockClawButtonPressed = true;
	}
	else if(!vexRT[Btn7D])
	{
		lockClawButtonPressed = false;
	}

	if(lockPincer)
	{
		clawAdditionalPower = 50;
	}
	else
	{
		clawAdditionalPower = 0;
	}
}


void pincherOpenClose()
{
	int zeroRightPot = 180; //Values to set the potentiometer value to zero
	int zeroLeftPot = 400;

	int positionOpenRight = 2600; //Potentiometer readings for each of the three positions and each arm
	int positionOpenLeft = 2000;
	int positionCloseRight = 4000;
	int positionCloseLeft = 3400;
	int positionFarRight = 1200;
	int positionFarLeft = 440;

	int pincerSpeed = 127;

	int tolorance = 25;

	//Open Position control
	if(vexRT[Btn5D])
	{
		//right pincher
		if(SensorValue[rightPot] > positionOpenRight + tolorance)
		{
			motor[rightPincer] = -pincerSpeed;
		}
		else if(SensorValue[rightPot] < positionOpenRight-tolorance)
		{
			motor[rightPincer] = pincerSpeed;
		}
		else
		{
			motor[rightPincer] = clawAdditionalPower;
		}

		//left pincher
		if(SensorValue[leftPot] < positionOpenLeft-tolorance)
		{
			motor[leftPincer] = pincerSpeed;
		}
		else if(SensorValue[leftPot] > positionOpenLeft+tolorance)
		{
			motor[leftPincer] = -pincerSpeed;
		}
		else
		{
			motor[leftPincer] = clawAdditionalPower;
		}
	}

	//Close control
	else if(vexRT[Btn5U])
	{
		//right pincer
		if(SensorValue[rightPot] > positionCloseRight+tolorance)
		{
			motor[rightPincer] = -pincerSpeed;
		}
		else if(SensorValue[rightPot] < positionCloseRight-tolorance)
		{
			motor[rightPincer] = pincerSpeed;
		}
		else
		{
			motor[rightPincer] = clawAdditionalPower;
		}

		//left pincher
		if(SensorValue[leftPot] < positionCloseLeft-tolorance)
		{
			motor[leftPincer] = pincerSpeed;
		}
		else if(SensorValue[leftPot] > positionCloseLeft+tolorance)
		{
			motor[leftPincer] = -pincerSpeed;
		}
		else
		{
			motor[leftPincer] = clawAdditionalPower;
		}
	}
	else if(vexRT[Btn8D])//Getting into tight corners
	{
		//right pincer
		if(SensorValue[rightPot] > positionFarRight+tolorance)
		{
			motor[rightPincer] = -pincerSpeed;
		}
		else if(SensorValue[rightPot] < positionFarRight-tolorance)
		{
			motor[rightPincer] = pincerSpeed;
		}
		else
		{
			motor[rightPincer] = clawAdditionalPower;
		}

		//left pincher
		if(SensorValue[leftPot]-zeroLeftPot < positionFarLeft-tolorance)
		{
			motor[leftPincer] = pincerSpeed;
		}
		else if(SensorValue[leftPot]-zeroLeftPot > positionFarLeft+tolorance)
		{
			motor[leftPincer] = -pincerSpeed;
		}
		else
		{
			motor[leftPincer] = clawAdditionalPower;
		}
	}
}

//Basic up down moving, when not suppose to move, adds power to make sure it wont move
void dumpControl()
{
	if(!vexRT[Btn7U]) //While not touching bottom sensor
	{
		if(vexRT[Btn6U])
		{
			additionalPower = 0;
			moveArm(127);
		}
		else if(vexRT[Btn6D])
		{
			additionalPower = 0;
			moveArm(-127);
		}
		else
		{
			lockArmUser();
		}
	}
	else //If bottom sensor pressed
	{
		moveArmDegree(1, 50);
		additionalPower = 0;
		lockArmPositionUser = nMotorEncoder[topRight];
	}
}

task usercontrol()
{
	nMotorEncoder[topRight] = 0;
	lockArmPositionUser = nMotorEncoder[topRight];
	additionalPower = 0;
	stopBase();
	moveArm(0);
	stopTask(odometry);
	while(true)
	{
		driveControl();
		dumpControl();
		movePincher();
		pincherOpenClose();
		lockClaw();
		wait10Msec(2); //Motors can only be updated every 20ms
	}
}

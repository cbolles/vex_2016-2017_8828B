#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pincerPot,      sensorPotentiometer)
#pragma config(Sensor, in3,    leftFollower,   sensorLineFollower)
#pragma config(Sensor, in4,    rightFollower,  sensorLineFollower)
#pragma config(Sensor, in5,    threeStarLine,  sensorLineFollower)
#pragma config(Sensor, dgtl1,  autoSensor,     sensorTouch)
#pragma config(Sensor, dgtl2,  bottomLimit,    sensorNone)
#pragma config(Sensor, dgtl3,  autoSensor,     sensorNone)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightPincer,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           bottomRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           topLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           bottomLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topRight,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port10,          leftPincer,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
*@author Collin Bolles
*Created 2/3/2017
*Code to completly run the 2016-2017 VEX Starstruck 8828B robot. Robot includes 4 motor mecanum wheel base, 
*6 motor arm, 2 motor pincer. Includes auto code with several possible modes controlled through VEX LCD display.
* Also included is complete drvier control on single joystick.
*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "autoInclude.h"

/**
*Allows drive team to pick an autonomous to run before the start of the match. The picking of the auto code is 
*done through the VEX LCD display. The user picks the autonomous to run from the four listed below.
*1) Basic Auto: Takes preload to VEX starstruck wall and dumps preload while knocking off three on wall
*2) Cube Auto: Runs basic auto, then grabs cube in middle and dumps cube on middle of wall
*3) Back Three Auto: Takes the back three stars and dumps them on the near part of wall
*4) Back Two Auto: Takes the preload and star next to robot and dumps both on near part of wall
*Additionally, the user choices which side of the field the robot starts on based on the location of the 
*cube in relation to the robot. By default the autonomous that is run is the cube autonomous assuming the cube
*is on the right of the robot.
*/
int autoSelect = 0; //0=cube, 1=basic,2=backThree, 3=backTwo
bool cubeAtRight = true;
void pre_auton()
{
	bLCDBacklight = true;
	int currentOption = 0;
	clearLCDLine(0);
	clearLCDLine(1);
	string autoOptions[] = {"cube", "basic", "backThree", "backTwo"};
	while(bIfiRobotDisabled) //Run while the robot is in "disabled mode"
	{
		clearLCDLine(0);
		clearLCDLine(1);

		if(nLCDButtons == kButtonRight)
		{
			currentOption++;
		}
		else if(nLCDButtons == kButtonLeft)
		{
			currentOption--;
		}

		if(currentOption > 3)
		{
			currentOption = 0;
		}
		else if(currentOption < 0)
		{
			currentOption = 3;
		}

		if(nLCDButtons == kButtonCenter)
		{
			autoSelect = currentOption;
		}

		if(nLCDButtons == kButtonLeft+kButtonRight)
		{
			cubeAtRight = !cubeAtRight;
		}

		if(currentOption == autoSelect)
		{
			displayLCDPos(1,0);
			displayNextLCDString("Selected");
		}


		displayLCDPos(0,0);
		displayNextLCDString(autoOptions[currentOption]);
		displayNextLCDString(" ");
		if(cubeAtRight)
		{
			displayNextLCDString("Right");
		}
		else
		{
			displayNextLCDString("Left");
		}
		wait1Msec(250);
	}
	bStopTasksBetweenModes = true;
}

/**
*The task below is run automatically by the field manager software once the auto period begins. The 
*autonomous to be run depends on which autonomous was selected by the drive team before the start of
*the match.
*/
task autonomous()
{
	clearTimer(T2);
	startTask(odometry);
	setToDefault();
	if(autoSelect == 0)
	{
		cube(cubeAtRight);
	}
	else if(autoSelect == 1)
	{
		basicAuto(cubeAtRight);
	}
	else if(autoSelect == 2)
	{
		backStars(cubeAtRight);
	}
	else if(autoSelect == 3)
	{
		backTwo(cubeAtRight);
	}
	writeDebugStreamLine("%d:",time1(T2)); //Used for testing to ensure the robot complets the auto in 15 seconds
}

/**
*The drive control function controls motion of the wheel base by user input. The drive base is a mecanum base using
*4 motors. Both joysticks are used to control the robot. Each joystick has a deadzone programmably implemented to 
*reduce stress on the motors and allow for easier driver control.
*/
void driveControl()
{
	//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

	if(abs(vexRT[Ch3]) > threshold)
		Y1 = vexRT[Ch3];
	else
		Y1 = 0;
	if(abs(vexRT[Ch4]) > threshold)
		X1 = vexRT[Ch4];
	else
		X1 = 0;
	if(abs(vexRT[Ch1]) > threshold)
		X2 = vexRT[Ch1];
	else
		X2 = 0;

	motor[frontRight] = Y1 + X2 + X1;
	motor[backRight] =  Y1 + X2 - X1;
	motor[frontLeft] = Y1 - X2 + X1;
	motor[backLeft] =  Y1 - X2 - X1;
}

/**
*Move pincher function controls the motion of the from pincer of the robot by the driver. The motion is 
*controlled by two buttons on the VEX control. One button opens both sets of pincers (as they are connected
*via gear chain) while the other closes them. If neither is pressed, the pincers get either 0 or 50 power
*depending on if the "lock" setting is true for the pincers (set by driver via remote)
*/
int clawAdditionalPower = 0;
void movePincher()
{
	int motorSpeed = 50;
	if(vexRT[Btn8L])
	{
		motor[leftPincer] = motorSpeed;
	}
	else if(vexRT[Btn8R])
	{
		motor[leftPincer] = -motorSpeed;
	}
	else
	{
		motor[leftPincer] = clawAdditionalPower;
	}

	if(vexRT[Btn7R])
	{
		motor[rightPincer] = -motorSpeed;
	}
	else if (vexRT[Btn7L])
	{
		motor[rightPincer] = motorSpeed;
	}
	else
	{
		motor[rightPincer] = clawAdditionalPower;
	}
}

/**
*Function that handles if additional power should be sent to the pincers when no driver input
*is being sent to the pincers. the boolean lockPincer is set by the driver from the joystick.
*This function is used when the robot has to hold tightly to an object without letting it fall
*such as a cube. 
*/
bool lockClawButtonPressed = false;
bool lockPincer = false;
void lockClaw()
{
	if(vexRT[Btn7D] && !lockClawButtonPressed)
	{
		lockPincer = !lockPincer;
		lockClawButtonPressed = true;
	}
	else if(!vexRT[Btn7D])
	{
		lockClawButtonPressed = false;
	}

	if(lockPincer && SensorValue[pincerPot] < 3900)
	{
		clawAdditionalPower = 50;
	}
	else
	{
		clawAdditionalPower = 0;
	}
}

/**
*Easier to use function to open and close the pincers. Instead of having the pincers either open
*or close at a single speed while a button is being pressed. This function allows the driver to
*set the position of the pincer arms using joystick buttons. The postions of the pincers are open, 
*close, and "far back" which represent the furthest towards the robot the pincers can open. The postions
*relate to a hard-coded potentiometer value. 
*/
void pincherOpenClose()
{
	int positionBack = 0;
	int positionOpen = 1960;
	int positionClose = 3800;
	int pincerSpeed = 127;

	int tolerance = 100;


	//Close Picer
	if(vexRT[Btn5U])
	{
		if(SensorValue[pincerPot] < positionClose-tolerance)
		{
			motor[rightPincer] = pincerSpeed;
			motor[leftPincer] = pincerSpeed;
		}
		else if(SensorValue[pincerPot] > positionClose+tolerance)
		{
			motor[rightPincer] = -pincerSpeed;
			motor[leftPincer] = -pincerSpeed;
		}
		else
		{
			motor[rightPincer] = 0;
			motor[leftPincer] = 0;
		}
	}
	//Open Pincer
	else if(vexRT[Btn5D])
	{
		if(SensorValue[pincerPot] < positionOpen-tolerance)
		{
			motor[rightPincer] = pincerSpeed;
			motor[leftPincer] = pincerSpeed;
		}
		else if(SensorValue[pincerPot] > positionOpen+tolerance)
		{
			motor[rightPincer] = -pincerSpeed;
			motor[leftPincer] = -pincerSpeed;
		}
		else
		{
			motor[rightPincer] = clawAdditionalPower;
			motor[leftPincer] = clawAdditionalPower;
		}
	}
	//Position Far
	else if(vexRT[Btn8D])
	{
		if(SensorValue[pincerPot] < positionBack-tolerance)
		{
			motor[rightPincer] = pincerSpeed;
			motor[leftPincer] = pincerSpeed;
		}
		else if(SensorValue[pincerPot] > positionBack+tolerance)
		{
			motor[rightPincer] = -pincerSpeed;
			motor[leftPincer] = -pincerSpeed;
		}
		else
		{
			motor[rightPincer] = clawAdditionalPower;
			motor[leftPincer] = clawAdditionalPower;
		}
	}
	else
	{
		motor[rightPincer] = clawAdditionalPower;
		motor[leftPincer] = clawAdditionalPower;
	}
}

/**
*Function that handles motion of the robot arm. The user can lift or lower the arm at a set speed.
*Addtionally, if the user is sending no input to the arm, the arm sets a lock position in which power
*is dynamically set to stop the arm sagging even if additional weight is added to the arm such as a 
*VEX star.
*/
void dumpControl()
{
	if(!vexRT[Btn7U]) //While not touching bottom sensor
	{
		if(vexRT[Btn6U])
		{
			additionalPower = 0;
			moveArm(127);
		}
		else if(vexRT[Btn6D])
		{
			additionalPower = 0;
			moveArm(-127);
		}
		else
		{
			lockArmUser();
		}
	}
	else //If bottom sensor pressed
	{
		moveArmDegree(1, 50);
		additionalPower = 0;
		lockArmPositionUser = nMotorEncoder[topRight];
	}
}

/**
*Task run automatically by field software. Contains all code for the the driver to drive the robot and interact
*with it throught the joystick.
*/
task usercontrol()
{
	nMotorEncoder[topRight] = 0;
	lockArmPositionUser = nMotorEncoder[topRight];
	additionalPower = 0;
	stopBase();
	moveArm(0);
	stopTask(odometry);
	while(true)
	{
		driveControl();
		dumpControl();
		pincherOpenClose();
		lockClaw();
		wait10Msec(2); //Motors can only be updated every 20ms
	}
}
